## 버블정렬

### 코드 구현

```
순서를 어느 한 쪽에서 부터 순서대로 바꾸는 기본적인 방식이다. 아래 코드는 임시로 변수를 저장할 temp를 이용해서 만약 앞에 있는 수가 뒤에 있는 수 보다 크다면 앞에 있는 수와 뒤에 있는 수를 바꾸게 한다. for문을 2번 이용하여 n^2번 만큼 곧이곧대로 정렬을 시도하는 방식. 첫 번째 시행을 할 때 가장 큰 수가 맨 뒤로 이동하여 정렬 대상에서 제외할 수 있지만 
```

```
import java.util.*;
public class bubble_sort{
    static void bubble(int[] arr, int n){
        for(int i= 0; i<n-1;i++){
            for(int j= 1; j<n-i;j++){
                if(arr[j]<arr[j-1]){
                    int temp = arr[j];
                    arr[j]=arr[j-1];
                    arr[j-1]= temp;
                }
            }
        }
    }
    public static void main(String[] args){
        int[] arr =new int[] {4, 3, 1, 2, 6, 5};
        int n = 6;
        System.out.println("======before sort======");
        for(int i = 0; i<n; i++){
            System.out.println("[Index"+(i+1)+"]: "+arr[i]);
        }
        System.out.println("======after sort======");
        bubble(arr, n);
        for(int i = 0; i<n; i++){
            System.out.println("[Index"+(i+1)+"]: "+arr[i]);
        }
    }
}
```

### 결과

![버브리](https://user-images.githubusercontent.com/80510925/117293047-e2a46f80-aeab-11eb-8154-c81d20a27889.PNG)

### 성능 평가

시간 복잡도는 for 문을 2개 사용해서 2번 중첩된 반복문을 예외없이 다 돌리니 (n^2)이 된다. 왜냐하면 첫 번째 정렬에선 n-1번을, 두 번째 시도에선 n-2번을, n-1번째 시도에선 1번을 확인, 정렬하기 때문이다. 횟수 자체로는 n(n-1)/2로 보일 수 있으나, 코드에서 예외사항을 지정해 주지 않는다면 n 번째도 확인하므로 n^2이 된다. 다른 정렬 알고리즘도 그렇지만 대부분의 성능 좋은 알고리즘은 절대 O(n^2)정도로 오래 걸리지 않는다. 따라서 비교하기도 전에 성능이 나쁘다는 것을 짐작할 수 있다. 다만 코드 자체는 굉장히 간단하고 짧다는 장점이 있다. 또한 배열의 현 상태에 상관없이 언제나 같은 성능을 보장한다. 심하게 말하면 이미 정렬이 다 된 배열과 정렬이 되어있지 않은 배열 두 배열을 정렬하는 속도를 비교해 봐도 배열의 크기가 같다면 동일한 시간이 걸린다.(정확히는 이미 정렬이 다 된 배열은 정렬을 하는데 시간이 그만큼 걸리는 것이 아닌 정렬이 되었는지 확인하는 것이기 때문에 숫자 위치를 바꾸어주는 시간 만큼 차이나긴 할 것이다. 이 때문에 동일한 시간복잡도를 가지는 뒤의 코드들에게도 성능이 밀린다.)

## 선택정렬

### 코드 구현

버블 정렬과 코드가 매우 유사하나, 방식에는 조금 차이가 있다.  가장 작은(또는 가장 큰, 아래 코드에서는 가장 작은) 숫자를 먼저 찾고, 맨 앞(맨 뒤)로 바로 이동시킨다. 버블 정렬과 선택 정렬 모두 앞 뒤 숫자를 순서대로 비교해 보는 것은 같으나, 버블 정렬은 비교를 하며 숫자를 이동시키고, 선택 정렬은 모두 비교해 본 후 한번에 이동시킨다는 차이점이 있겠다.

``` 
버블 정렬과 다르게 if문에서 비교하는 대상이 인접해 있을 필요는 없다. i는 처음에는 배열의 가장 앞쪽에 있는 것을 나타내는데, 한 번 정렬을 할 때 마다 가장 앞에 있는 숫자는 가장 작은 숫자가 되기 때문에 비교 대상을 방금 옮긴 숫자 바로 뒤에 있는 숫자로 옮겨준다. 즉 i에 1을 더한다.
i와 비교하는 대상은 아직 정렬되지 않은 곳에서의 최솟값, min이다. i와 min이 같지 않다면 i는 아직 정렬되지 않은 숫자들 중 배열의 가장 앞쪽에 있으므로 i와 min의 위치를 서로 바꾸어준다.
```

```
public class selection {
    public static void main(String[] args) {
        int[] arr = {4, 3, 1, 2, 6, 5};
        int temp = 0;
        int min = 0;
        int n = arr.length;
        System.out.println("======before sort======");
        for(int x=0; x<n; x++) {
            System.out.println("[Index"+(x+1)+"]: "+arr[x]);
        }
        for(int i = 0; i < n-1; i++) {
            min = i;
            for(int j = i+1; j < n; j++) {
                if(arr[j] < arr[min]) {
                    min = j;
                }
            }
            if(i != min) {
                temp = arr[min];
                arr[min] = arr[i];
                arr[i] = temp;
            }
        }
        System.out.println("======after sort======");
        for(int j=0; j<n; j++){
        System.out.println("[Index"+(j+1)+"]: "+arr[j]);
        }
    }
}
```

결과는 모두 동일하게 나오도록 했기에 생략한다.

### 성능 평가

물론 한번 비교할 때 마다 매번 1/2의 확률로 요소의 위치를 바꿔주어야 하는 버블정렬보다 위치 변경 횟수가 훨씬 적지만, 요소 크기 비교 검사 횟수는 같다. 시간복잡도도 마찬가지로 O(n^2)이며 따라서 성능이 좋지 않다고 볼 수 있다.
이 코드도 결국 앞 뒤 숫자 중 무엇이 더 큰지 검사하는 횟수는 배열의 상태와 관계없이 변함이 없다.

## 삽입 정렬

### 코드 구현

이 코드도 앞과 뒤를 비교해서 더 작은 것을 맨 앞으로 옮긴다는 점에선 선택 정렬과 비슷하다. 버블 정렬도 마찬가지. 다만 삽입 정렬의 경우에는 2번째 요소부터 앞쪽으로 오며 검사를 하는 독특한 방식을 취하고 있다.

```
코드를 구현할 때 특이사항 중 하나로, while 문을 사용한다면 상관 없겠지만,for 문을 사용할 때 break를 집어넣지 않으면 시간 소모량이 이해할 수 없을 정도로 길어져서(아래와 같이 배열에 숫자를 많이 넣지 않으면 크게 와 닿진 않지만) break를 집어넣어야 한다.
```

```
public class insert{
    public static void main(String[] args) {
        int n = 6;
        int arr[] = {4, 3, 1, 2, 6, 5};
        System.out.println("======before sort======");
        for(int x=0; x<n; x++) {
            System.out.println("[Index"+(x+1)+"]: "+arr[x]);
        }
        for(int i=1 ; i<n ; i++) {
            for(int j=i-1 ; j>=0 ; j--) {
                if(arr[j]<=arr[j+1]) break;
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
        System.out.println("======after sort======");
        for(int i=0 ; i<n ; i++) System.out.println("[Index"+(i+1)+"]: "+arr[i]);
    }
}
```

### 성능 평가

정렬이 이미 되어있는 경우 시간복잡도가 n이다. 왜냐하면 이 때의 비교 횟수가 n-1 번이기 때문.  이런 최선의 상황에선 시간복잡도도 O(n)이 나온다고 한다.
그런데 이미 정렬이 되어 있는 상황을 상정한 것이기 때문에 언제나 이런 성능을 보여주진 못하고, 심하게 운이 나쁜 경우 O(n^2)의 시간 복잡도를 가지기도 한다고 한다. 그래도 앞서 나온 2 알고리즘보다는 러닝 타임을 앞당길 여지를 가지고 있어 더 효율적이라고 볼 수 있다.
삽입 정렬의 또 다른 취약점으로 이동 횟수가 있는데, 배열의 마지막 숫자가 작은 숫자일 경우 그 숫자가 앞쪽에 삽입되면 그 숫자 때문에 여러 많은 숫자가 뒤로 이동해야 하는 경우가 생길 수 있다.

## 쉘 정렬

삽입 정렬에서 아쉬웠던 이동 횟수를 보완하는 정렬 방식. 먼저 배열의 요소들의 총 갯수보다 크지 않게 나눌 수 있는, 예를 들어 배열의 요소의 개수가 15개 일 때 요소의 갯수가 3개인 5개의 그룹들로 나누어 그룹 별로 삽입 정렬을 수행한다. 그 다음 앞서 나눈 것 보다 그룹의 개수를 줄여 다시 삽입 정렬을 수행하고, 차츰 줄이다 마지막에는 단일 그룹, 배열 전체에 대해 삽입 정렬을 시행하는 방식으로 진행된다.

### 코드 구현

```
2번째 for문은 삽입 정렬을 나타내고, 3번 째 for문은 나뉘어진 그룹 별로 연산을 하도록 하기 위한 장치인 것 같다.
```

```
public class shell {
    public static void main(String[] args) {
        int[] arr = {4, 3, 2, 1, 6, 5};
        int n = arr.length;
        for(int gap = n / 2; gap > 0; gap /= 2) {
            for(int i = gap; i < n; i++) {
                int j;
                int temp = arr[i];

                for(j = i - gap; j >= 0 && arr[j] > temp; j = j- gap) {
                    arr[j + gap] = arr[j];
                }
                arr[j + gap] = temp;
            }
        }
        for(int x=0; x<n; x++) {
            System.out.println("[Index"+(x+1)+"]: "+arr[x]);
        }
    }
}
```

### 성능 평가

어떻게 나누느냐, 얼마나 정렬이 되어있었느냐 등 여러 조건이 붙어 시간복잡도를 계산할 수 없었다. 다만 확실히 알 수 있는 것은 이 역시 기반을 삽입 정렬에 두고 있기 때문에 최악의 경우에는 시간복잡도가 O(n^2)이 된다는 것은 동일하다.  